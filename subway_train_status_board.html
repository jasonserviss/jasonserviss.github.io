<!DOCTYPE html> <html>
<head>
  <meta charset="utf-8">
  <script src="d3.js"></script>
  <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  <script>
    
    <!--The data has the following JSON format:-->
    <!--{-->
    <!--  "status": ["GOOD SERVICE"], "name": ["123"],-->
    <!--  "url": [null],-->
    <!--  "text": ["..."], "plannedworkheadline": [null], "Time": [" 7:35AM"],-->
    <!--  "Date": ["12/15/2011"]-->
    <!--}-->
  
    function draw(data) {
      "use strict";
      d3.select("body") <!--Select the body-->
      
      .append("ul") <!--Append a ul tag (unordered list)-->
      
      .selectAll("li") <!--selectAll list elements on the page, even though we know there aren’t any. This prepares the way for new list elements to enter the visualization. Practically, this creates the empty selection, which is an array with no elements, but that has been blessed with a data method, allowing it to accept data. a li tag generates a list item-->
      
      .data(data) <!--The data method joins the empty selection with each element of the data set. This results in a selection that is an array with as many elements as we have data points (subway lines). We’re still not quite there: this array’s elements are all empty, however this selection has a new enter method.-->
      
      .enter() <!--The enter method returns a selection whose array contains the data for all the new elements we’re going to create; all the elements for which we have data but don’t already have items on the page. This is called the enter selection. The .enter() method returns a selection containing data for all 11 data elements. This enter selection is now ready for us to append elements to it.-->
      
      .append("li") <!--Finally, we need to tell D3 what to do with each element of the entering selection we’ve just created. For this visualization, we append an <li> element to the enter selection whose text contains the name of the line and its status.-->
      
      .text(function (d) {
        return d.name + ": " + d.status;
      }); <!--To access individual elements of the data, we need to write a callback function as the text’s second argument. This function is passed the current element in the data set and the index of that element. For this example, our callback accesses two elements of the data—the name and status—and simply concatenates them, returning the result.-->
      
      <!--Adding Data-Dependent Style-->
      d3.selectAll("li")
      .style("font-weight", function (d) {
             if (d.status == "GOOD SERVICE"){
              return "normal";
             } else {
              return "bold";
             } 
      })

    }
  </script>
</head>
<body>
  <script>
    d3.json("data/service_status.json", draw);
  </script>
  <code class="prettyprint">
    &lt;!--The data has the following JSON format:--&gt;<br/>    &lt;!--{--&gt;<br/>    &lt;!--  &quot;status&quot;: [&quot;GOOD SERVICE&quot;], &quot;name&quot;: [&quot;123&quot;],--&gt;<br/>    &lt;!--  &quot;url&quot;: [null],--&gt;<br/>    &lt;!--  &quot;text&quot;: [&quot;...&quot;], &quot;plannedworkheadline&quot;: [null], &quot;Time&quot;: [&quot; 7:35AM&quot;],--&gt;<br/>    &lt;!--  &quot;Date&quot;: [&quot;12/15/2011&quot;]--&gt;<br/>    &lt;!--}--&gt;<br/>  <br/>    function draw(data) {<br/>      &quot;use strict&quot;;<br/>      d3.select(&quot;body&quot;) &lt;!--Select the body--&gt;<br/>      <br/>      .append(&quot;ul&quot;) &lt;!--Append a ul tag (unordered list)--&gt;<br/>      <br/>      .selectAll(&quot;li&quot;) &lt;!--selectAll list elements on the page, even though we know there aren&#x2019;t any. This prepares the way for new list elements to enter the visualization. Practically, this creates the empty selection, which is an array with no elements, but that has been blessed with a data method, allowing it to accept data. a li tag generates a list item--&gt;<br/>      <br/>      .data(data) &lt;!--The data method joins the empty selection with each element of the data set. This results in a selection that is an array with as many elements as we have data points (subway lines). We&#x2019;re still not quite there: this array&#x2019;s elements are all empty, however this selection has a new enter method.--&gt;<br/>      <br/>      .enter() &lt;!--The enter method returns a selection whose array contains the data for all the new elements we&#x2019;re going to create; all the elements for which we have data but don&#x2019;t already have items on the page. This is called the enter selection. The .enter() method returns a selection containing data for all 11 data elements. This enter selection is now ready for us to append elements to it.--&gt;<br/>      <br/>      .append(&quot;li&quot;) &lt;!--Finally, we need to tell D3 what to do with each element of the entering selection we&#x2019;ve just created. For this visualization, we append an &lt;li&gt; element to the enter selection whose text contains the name of the line and its status.--&gt;<br/>      <br/>      .text(function (d) {<br/>        return d.name + &quot;: &quot; + d.status;<br/>      }); &lt;!--To access individual elements of the data, we need to write a callback function as the text&#x2019;s second argument. This function is passed the current element in the data set and the index of that element. For this example, our callback accesses two elements of the data&#x2014;the name and status&#x2014;and simply concatenates them, returning the result.--&gt;<br/>      <br/>      &lt;!--Adding Data-Dependent Style--&gt;<br/>      d3.selectAll(&quot;li&quot;)<br/>      .style(&quot;font-weight&quot;, function (d) {<br/>             if (d.status == &quot;GOOD SERVICE&quot;){<br/>              return &quot;normal&quot;;<br/>             } else {<br/>              return &quot;bold&quot;;<br/>             } <br/>      })<br/><br/>    }<br/>
    </code>
</body>
</html>